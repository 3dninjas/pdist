{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A better way for distributing your Python packages. Documentation : https://3dninjas.github.io/pyscriptpacker/ Source Code : https://github.com/3dninjas/pyscriptpacker Pyscriptpacker helps converting your Python packages into a single file that makes the distribution of your projects much more simple. The key features are: Single file distribution: The final result will be a single file module which allows the file can be easily placed into any other projects. Extending libraries: Pyscriptpacker support packing external modules to your project as long as it is a Python library and can be installed via pypi (or you can provide the path to the library manually). Zip output: The user can use Pyscriptpacker for zipping the output and other files/folder together with custom path support for a desired structure. Compressing & minifying: Pyscriptpacker has an option which can be used to compress and minify all the sources to add a security layer for your code. Python 2 & 3: Pyscriptpacker is compatible with both python 2 & 3, so it can support with projects with both versions. Please see feature for more information. Quick start $ pip install pyscriptpacker $ pyscriptpacker --help Usage: python -m pyscriptpacker [options] module1,module2,.. path1,path2,.. output Pyscriptpacker also provides a number of command line arguments. --version Show the Pyscriptpacker's version and exit. -h, --help Show the Pyscriptpacker's help message and exit. -c, --compress Default: false - This option allow to compress the sources and the packed file. -i, --minify Default: false - Minify the source code using the pyminifier package. -m main_file, --main=main_file Default: [] - Append main file's script to the bundle, which allow it to be executed whenever we import the result file. -z zip_file, --zip=zip_file Default: None - Zip the result script into the input zip file. -r path,..., --resources=path,... Default: [] - Add resource files and folders to the zip file, using their basename or a custom path annotated with a colon, e.g. -z ./res/logo.png:logo.png -k package,..., --packages=package,... Default: [] - install additional packages to a temporary virtual python environment, can be used for searching and packing. -p python_path, --python=python_path Default: sys.executable - specify the python path used for the parameter of virtualenv tool. If this argument is not provided, pyscriptpacker will try getting the default path. License GNU General Public License v3.0 Copyright (C) 2021 3D Ninjas GmbH This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"Overview"},{"location":"#quick-start","text":"$ pip install pyscriptpacker $ pyscriptpacker --help Usage: python -m pyscriptpacker [options] module1,module2,.. path1,path2,.. output Pyscriptpacker also provides a number of command line arguments. --version Show the Pyscriptpacker's version and exit. -h, --help Show the Pyscriptpacker's help message and exit. -c, --compress Default: false - This option allow to compress the sources and the packed file. -i, --minify Default: false - Minify the source code using the pyminifier package. -m main_file, --main=main_file Default: [] - Append main file's script to the bundle, which allow it to be executed whenever we import the result file. -z zip_file, --zip=zip_file Default: None - Zip the result script into the input zip file. -r path,..., --resources=path,... Default: [] - Add resource files and folders to the zip file, using their basename or a custom path annotated with a colon, e.g. -z ./res/logo.png:logo.png -k package,..., --packages=package,... Default: [] - install additional packages to a temporary virtual python environment, can be used for searching and packing. -p python_path, --python=python_path Default: sys.executable - specify the python path used for the parameter of virtualenv tool. If this argument is not provided, pyscriptpacker will try getting the default path.","title":"Quick start"},{"location":"#license","text":"GNU General Public License v3.0 Copyright (C) 2021 3D Ninjas GmbH This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"License"},{"location":"example/","text":"Qt app A small qt app to demonstrate the usage of Pyscriptpacker Here is a simple qt app, using Pyscriptpacker to pack a custom widget library ( my_lib ) and then use it as a separate module for other projects. Packer command line: $ pyscriptpacker -c custom_widgets ./unpacked ./packed/my_lib.py Note The -c flag is used for compression, see here for more information. Looking at the command line use for packing, we provided these information to the Pyscriptpacker: The module name we want to pack. ( custom_widgets ) The path to that module. ( ./unpacked ) The output file and where it should be. ( ./packed/my_lib.py ) Pyscriptpacker will go through all the files in the module and add the source codes into the virtual_module variable, then use the custom loader whenever we call to the packed file. Important Please note that we need to import the packed file first before actually calling any modules in it. # import our packed file first for initialize our virtual bundle import packed.my_lib from packed.my_lib.custom_widgets.main_window import MainWindow Blender addon Blender addon using Pyscriptpacker for packing into a zip file Here is a simple example, using Pyscriptpacker to pack this blender example addon . Packer command line: $ pyscriptpacker -z packed/addon.zip -m ./unpacked/__init__.py addon ./unpacked ./example_addon/__init__.py This example is quite similar to the qt example app except: In this example, we use a flag -m main_file, --main=main_file which helps the user to determine the main script which need to be executed when import that module, also a requirement for addon to be regconized by Blender ( bl_info in __init__.py ). Furthermore, we use -z zip_file, --zip=zip_file for zipping our output example addon into a zip file, so we can just take that zip file and release the addon. Warning The -c, --compress does not work well when you are trying to deliver a Blender addon due to Blender has to parse the file and look for bl_info before actually import the addon.","title":"Example"},{"location":"example/#qt-app","text":"A small qt app to demonstrate the usage of Pyscriptpacker Here is a simple qt app, using Pyscriptpacker to pack a custom widget library ( my_lib ) and then use it as a separate module for other projects. Packer command line: $ pyscriptpacker -c custom_widgets ./unpacked ./packed/my_lib.py Note The -c flag is used for compression, see here for more information. Looking at the command line use for packing, we provided these information to the Pyscriptpacker: The module name we want to pack. ( custom_widgets ) The path to that module. ( ./unpacked ) The output file and where it should be. ( ./packed/my_lib.py ) Pyscriptpacker will go through all the files in the module and add the source codes into the virtual_module variable, then use the custom loader whenever we call to the packed file. Important Please note that we need to import the packed file first before actually calling any modules in it. # import our packed file first for initialize our virtual bundle import packed.my_lib from packed.my_lib.custom_widgets.main_window import MainWindow","title":"Qt app"},{"location":"example/#blender-addon","text":"Blender addon using Pyscriptpacker for packing into a zip file Here is a simple example, using Pyscriptpacker to pack this blender example addon . Packer command line: $ pyscriptpacker -z packed/addon.zip -m ./unpacked/__init__.py addon ./unpacked ./example_addon/__init__.py This example is quite similar to the qt example app except: In this example, we use a flag -m main_file, --main=main_file which helps the user to determine the main script which need to be executed when import that module, also a requirement for addon to be regconized by Blender ( bl_info in __init__.py ). Furthermore, we use -z zip_file, --zip=zip_file for zipping our output example addon into a zip file, so we can just take that zip file and release the addon. Warning The -c, --compress does not work well when you are trying to deliver a Blender addon due to Blender has to parse the file and look for bl_info before actually import the addon.","title":"Blender addon"},{"location":"features/","text":"Pyscriptpacker provide the following: Single file distribution Pyscriptpacker will go through all the source files within the requested module and pack them into a single file. The user can place the file anywhere, under any module and the result file still work pretty well thanks to our custom loader code . You can take a look at some examples in here . Extending the libraries You can also pack external Python modules to your packed file as well by installing it in your Python environment and then provide the site-packages path to the Pyscriptpacker. For example: $ pip install pyscriptpacker, toposort $ pyscriptpacker toposort <path_to_site-packages> output.py Another way to do this without installing the external package manually is to use the -k and the -p flags. $ pip install pyscriptpacker $ pyscriptpacker -k toposort -p <python_path> toposort ..... output.py Pyscriptpacker will automatically create a temporary virtual environment and install the desired packages (identify with -k flag) to that virtual environment, it also add the site-packages path of that environment to the search path when Pyscriptpacker trying to find the module to pack. The -p python_path, --python=python_path is an optional way to tell Pyscriptpacker use custom python path as the interpreter which virtual environment is created based on. Note If the user does not define the -p python_path , Pyscriptpacker will use the default python path in the current environment ( sys.executable ). Compressing & Minifying Pyscriptpacker does have an option to compress the source code using the bz2 method, so it will add a security layer to your source file and still can be imported as module and working correctly. Take the above toposort module source code as an example, here is the packing result from Pyscriptpacker with and without the compression option. -c, --compress -i, --minify Furthermore, Pyscriptpacker does implement the pyminifier package's functionality to help minify the source code. See here for more information about pyminifier package. Zipping output -z zip_file, --zip=zip_file and -r path, --resources=path,... These two options allow Pyscriptpacker instead of just output into a single file, it will add the result file into the desired zip file and also includes all the resource files/folders (if any). Moreover, the resource flag does have a support for custom path, where PyscriptPacker will structure the resource file as you wish by using color : as an annotation and then define your custom path. For example: -r README.md:Folder/README.md zip_file.zip \u251c\u2500 Folder/ \u2502 \u2514\u2500 README.md \u2514\u2500 other_file.py -r README.md zip_file.zip \u251c\u2500 README.md \u2514\u2500 other_file.py","title":"Features"},{"location":"features/#single-file-distribution","text":"Pyscriptpacker will go through all the source files within the requested module and pack them into a single file. The user can place the file anywhere, under any module and the result file still work pretty well thanks to our custom loader code . You can take a look at some examples in here .","title":"Single file distribution"},{"location":"features/#extending-the-libraries","text":"You can also pack external Python modules to your packed file as well by installing it in your Python environment and then provide the site-packages path to the Pyscriptpacker. For example: $ pip install pyscriptpacker, toposort $ pyscriptpacker toposort <path_to_site-packages> output.py Another way to do this without installing the external package manually is to use the -k and the -p flags. $ pip install pyscriptpacker $ pyscriptpacker -k toposort -p <python_path> toposort ..... output.py Pyscriptpacker will automatically create a temporary virtual environment and install the desired packages (identify with -k flag) to that virtual environment, it also add the site-packages path of that environment to the search path when Pyscriptpacker trying to find the module to pack. The -p python_path, --python=python_path is an optional way to tell Pyscriptpacker use custom python path as the interpreter which virtual environment is created based on. Note If the user does not define the -p python_path , Pyscriptpacker will use the default python path in the current environment ( sys.executable ).","title":"Extending the libraries"},{"location":"features/#compressing-minifying","text":"Pyscriptpacker does have an option to compress the source code using the bz2 method, so it will add a security layer to your source file and still can be imported as module and working correctly. Take the above toposort module source code as an example, here is the packing result from Pyscriptpacker with and without the compression option. -c, --compress -i, --minify Furthermore, Pyscriptpacker does implement the pyminifier package's functionality to help minify the source code. See here for more information about pyminifier package.","title":"Compressing &amp; Minifying"},{"location":"features/#zipping-output","text":"-z zip_file, --zip=zip_file and -r path, --resources=path,... These two options allow Pyscriptpacker instead of just output into a single file, it will add the result file into the desired zip file and also includes all the resource files/folders (if any). Moreover, the resource flag does have a support for custom path, where PyscriptPacker will structure the resource file as you wish by using color : as an annotation and then define your custom path. For example: -r README.md:Folder/README.md zip_file.zip \u251c\u2500 Folder/ \u2502 \u2514\u2500 README.md \u2514\u2500 other_file.py -r README.md zip_file.zip \u251c\u2500 README.md \u2514\u2500 other_file.py","title":"Zipping output"}]}