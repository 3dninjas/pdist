_virtual_modules = {
    "tests.test01": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWd2SV90AAFdfgAAQQOd/4gACBAC/r94gIACVCJqGagaDJ6mQaAAEpAKZoamJ6mRoaDBKNXscLWLvTu82Epn4GxSp7aFOvmzpJyQ65FnubEG1TPWkydFG9JE0YFeg0YXMCAQB1XZirIALdAC1le3SVapppOuTcwYSypchvaQ3xfF4z6pO2NpDMWbm1pMhy4R5zf5wUilFwRrBkbhFOeKskV6HGB/F3JFOFCQ3ZJX3QA==")))\n',
    },
    "tests.test02": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWXpLxBQAAHpfgAAQQOd/4gACBAC/r94gMADSyGigBoBk2oABoBoSntDVPFNHqD1MIAASSob1TJmpk2kaNNNAyekk72uoG40CWLEL8ImGfEYTKivDGIjda3DFX5WEQTQrddvY0BHdD1nNdlK88JLcpbwj3wSLVaiI6MtITOCVCaWIsDFMUs9H7XNOQZEGTcAjRa9zr7EUYcSGOolZyqzI+UTKOUHFI5m8l3Hg583MyxURzHYpL8WF+U+qHLHwOzJmVqKSCNtJak0zsca1AzNS8vxdyRThQkHpLxBQ")))\n',
    },
    "tests.test03": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWTZ6a18AAKTfgAAQQOd/4gECBAC/b94gMADxYGlNDRoaDTTQNAaGgNNInqYk2o0xpBo0A0BJKYmkHqPU09RppiABosT8Z9hD3BcycBIHMRYOGoQVB7UusFqCcG1BmQREDAUpUKPvDBBHLo3jFyoQSiFU3uu417SIT4TgsobpPXRzYwaUapWlnRWt5yQUCcgcRfppdu1CdWHI2IswhTiAMZi5wpjjeBAeBiD6Qkn19AWEpiByJ639C8gg0FFE8QOAoLy4ZMnYkzCieOqX5H0mrrBZogttpX1RcMNnUpFKJbByT5FBDQsYnqIlqjMvUitfxdyRThQkDZ6a18A=")))\n',
    },
    "tests.test04": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWbJpGqQAAD1ZgAAQQON34j8n3AAgAHQSoIaNBmpo0aBoJVDyTagGI0ABWVKYCHxIwYsV8R5sRKnMa0OJzEIDDEkMy4HCxxMcZji8eQRcy0lzAyOTxUxDUoVngNJHedU8ayJ6qq7GRTRGPK2U/F3JFOFCQsmkapA=")))\n',
    },
    "tests.test05": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWY2E6AkAABtbgAAQQOBiAgAAtyfeACAAVFDQNNNABoRNGk8U00/VNND0ibTRqFiCFn3RjBC9lqBzjyWYWtGjU1MncHmS6QCBJ9tdoqFzy38XckU4UJCNhOgJ")))\n',
    },
    "tests.test06": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWYsx8LoAAETfgAAQQOd/4gACBAA/J94gIACFDVT/VTPSnhTyamano9QQeoBpqEBppoDQAAWR5NwTJb/nkgQrTrFN4F1Ka7YoNIvmGEmsC561GisZB3NjMGltcljPehxUT8DBvq72BMut2tLUXiUkH1Vhj9Wwhpt2U9MSOQO5qU+RiOX9BwJIeJ2hcGoCgWQnx+7j+LuSKcKEhFmPhdA=")))\n',
    },
    "tests.test07": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWW851fwAACjZgAAQQON+4j8n3gAgAFQ1TagHqbUA0ZHpNqFTJ6nqemUD00IAATgC2nv65pGgRVZ0SJlhdLV5RqzqVEUOAjkTyaWfe7oJJ+xBUQ6QNWGjOObwtrFiVL9UiWAazpB+LuSKcKEg3nOr+A==")))\n',
    },
    "tests.test08": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWc4axYkAAA5bgAAQQOFgQAAAkifeACAAIap5T0noEGeihRoyBo0yNGTuLur3UZwOvGFUsWygOqKdhzA+Mz+LuSKcKEhnDWLEgA==")))\n',
    },
    "tests.test09": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWfTz6y8AAA5bgAAQQOFgIAAAkifeACAAIap5T0noEGeihRoyBo0yNGTuLur3UZwOvGFUsWygOqKdhzA+Mz+LuSKcKEh6efWXgA==")))\n',
    },
    "tests.test10": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWUZ8dJkAABDbgAAQQOFgAAAAsi/eACAAMUAGI000aDU0DTQAaDyv2RtNAK4eI8y4IU1zC5A8bNy8CL0bT3vi7kinChIIz46TIA==")))\n',
    },
    "tests.test11": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWdcqmkIAAGNfgAAQQPd/ogACBAA/J94gMAC7bBqmg9IHpNDRtIA0BFHo9UZNpANAGgASip4mp6m01PSeptI0yDCauSxzRaG2QpNT4sSd63EnZlqjXWVNCtzzsPfKGGJDoqkD0BNi+J5pqTnUgmsuM1ihTFRrDVgzyKA2BB2DhoAi1K5I1vPsEGNU1AgiIGb8Yhk0NQKkq/JX4w3MWQN2DRb8DAVIhsPkcIakWfekwVUkFpEGZFoiuSkwmns0IBwUT+LuSKcKEhrlU0hA")))\n',
    },
    "tests.test12": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWem0v9IAABDbgAAQQOEwAAAAsi/eACAAMUAGI000aDVPU2jT1QwGiKldlu2I+sogJauoKePeNUDWy0H0C+xk85+LuSKcKEh02l/pAA==")))\n',
    },
    "tests": {
        "is_package": True,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWYP7PpQAAKXfgEQQQOF/8gIAAACvL97AMAC7bBkoBoAD1ABoANNJAAADQAAEVSaPUw0CNAaAZHqTiOFNRXGy26/CG4XCIqFwj4BxB9A5cQTNAm/aBGqrX4wEtcQAi5WEkhjCpVSSSSSiJO7SqqqrfIxlloBmINXX2HgboAWqCeQDLuAdGEwFgMM7doOQNIMtUigHz+oR3g0SBn0BrvzBiDXRfAWoHEXZKYGOvSmX8XckU4UJCD+z6UA=")))\n',
    },
    "lib1.mod1": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWcCsBi0AABZZgAAQQIJe4j4gAgAgACKaHqDTEyBTCaaA0xKI6gzbjXSCF3aXHGVoAmCwqQ5b03TPPvfF3JFOFCQwKwGLQA==")))\n',
    },
    "lib1.test08_util": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWQK87BwAABzZgAAQQIN94j8m3gAgAFRFNMEwCMAnkGqZonqNDNTyj1ABlVfRidskahWWKsIDe8mUaRISCVRXDnTaDynMLcP2QJ8AYP4wbggLgu5IpwoSAFedg4A=")))\n',
    },
    "lib1.test09_util": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWeNqNvwAAFDZgAAQQIN/4j8m3gAgAJIJVNqNGjE00aBpiCU1CYRlPU2ptQGhN7kldn9l9Z2VJrjn8NctMuKODi2+aGpARWbSFoUKZcSMBIjFtoGdGdUhY6CJ643SK9zYuNcQJDRfZgC4owevEguYMPHkVVHHBGZbeR8iJGgVVtQedFrmfi7kinChIcbUbfg=")))\n',
    },
    "lib1": {
        "is_package": True,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWXc9WE0AACxbgAAQQIJ/4gAAv6/GACAAVDU0mmjQZGIaNqeghTynqepoZpNqNAAQyF1BtAUYscpvDcjySkEaeZHRFVrNVmPoVCoPikSxD99KM+QGevTbFFf/NAgsMGbAjuLuSKcKEg7nqwmg")))\n',
    },
    "lib1.pak1.mod2": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWeXOR1wAABZZgAAQQIJ+Yj8gAgAgADFA00MjJiEQ0GmahoEg9qIFfIIHxTVKZkWuVM7YbbhtJ2LdIe98XckU4UJDlzkdcA==")))\n',
    },
    "lib1.pak1.test10_util": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWU36e/0AAEPfgAAQQOd+4gACBAC+r95gMAC1kNTU0000NGmmmjQGgAap6TagMhoZDTQAAklR5NIeiekep6ho0DI9To0EE4FHcPVvp8MgEBxqEAHlOo2tzTWwIvlxWwByyophgMYIUqRCGJJNzyFgWHEd52aXl3GYZGiHE2roTdoE2UTO45ajPDJPW16/SKU+NaMRsU1CELOeAtwx9RoXifVDhcaJkMpK02KhUThlFX+VKVRpvxdyRThQkE36e/0=")))\n',
    },
    "lib1.pak1.test12_util": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWZHkPiEAAFVfgAAQSOd/4gACBIC/797gMADNtg1NJ6ajKNHqZlGT0jINGT1AimmjIGhoAaNNANPUA1MhPU1Mm0nqeSYj01AADRq6QnM414OHQ9ff5ayAP4NVkXgn5pA+9oxfHixIkzDRcyuDRTIYkAbkpqbwnoa6NRIF1ScRQoFEYgwYkgVmUcVARvRAAldST5sMU8hXklWgIxbbRSd+GJAsMEAR3dapzdOlVagy8SCDakKPtr2o315qDtMpKEBIJRcRnYIU+1oWzTMKywb7U5QvW8PleawQBYXG1m0MRBbU4fiUEZUERqwK42PYwrXZyH8XckU4UJCR5D4h")))\n',
    },
    "lib1.pak1": {
        "is_package": True,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWT600r4AABZZgAAQQIJ/4h8gAgAgADFGjIGjTI0Ipk8p6mnk1H6TSXgKjPN8gQChgUoZri1mNzWSVKcuRVb3+LuSKcKEgfWmlfA=")))\n',
    },
    "lib2.mod3": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWS+JUp8AABZZgAAQQIJ/4j8gAgAgACMPJpqNo0T9ICgAxGmmjQnEIRD0wtIwIfr85x8hoLu1loy6uec6be+C7kinChIF8SpT4A==")))\n',
    },
    "lib2": {
        "is_package": True,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWU5DIDcAABZZgAAQQIJ94j8gAgAgADFGjIGjTI0IptT0Ex6h6p6CgyiKYKjS68fP5KBfUZBh2mYO24pL7POdF3JFOFCQTkMgNw==")))\n',
    },
    "lib3.auto1": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWTRbIkkAABZZgAAQQIJ/oj4gAgAgADFA00MjJiFTZNT1Gj8qep+qaMPZgW7QJQeoeEa5eZWGfhgrV59JOc61+LuSKcKEgaLZEkg=")))\n',
    },
    "lib3.auto2": {
        "is_package": False,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWS6lqysAABZZgAAQQIJ9oj8gAgAgADFA00MjJiFDTQaZGnqE1e5iBDKMbatYPW+0Cco2SLp9k54G1lj3vi7kinChIF1LVlY=")))\n',
    },
    "lib3": {
        "is_package": True,
        "code": 'import bz2, base64\nexec(bz2.decompress(base64.b64decode("QlpoOTFBWSZTWVYXwUQAAA7bgEAQQIQwAgAKoASGACAAISoyaMRoFMABNEHYhSzEzEwSUOO9IgwtdPCHxdyRThQkFYXwUQA=")))\n',
    },
}


import json
import hashlib
import sys
import imp
try:
    import __builtin__ as builtins
except ImportError:
    import builtins

_bundle_hash = hashlib.sha256(
    json.dumps(_virtual_modules, sort_keys=True).encode('utf-8')).hexdigest()

print('Packer: init bundle_hash={}'.format(_bundle_hash))


def _try_load_module(name, local_name, parent_name, override):

    # qualified names
    qf_name = '{}.{}'.format(__name__, name)
    qf_parent_name = '{}.{}'.format(
        __name__, parent_name) if parent_name else __name__

    # check if module is not loaded already and available
    virtual_module = _virtual_modules.get(name, None)
    if not virtual_module or qf_name in sys.modules:
        return
    if not override:
        if hasattr(sys.modules[qf_parent_name], local_name):
            return

    # debug
    print(
        'Packer: loading name={}, qf_name={}, local_name={}, parent_name={}, qf_parent_name={}, override={}'
        .format(
            name,
            qf_name,
            local_name,
            parent_name,
            qf_parent_name,
            override,
        ))

    # create module object
    module = sys.modules[qf_name] = imp.new_module(qf_name)
    setattr(module, '__packer_bundle_hash__', _bundle_hash)
    module.__name__ = qf_name
    if virtual_module['is_package']:
        module.__package__ = qf_name
        module.__path__ = ['{}/{}'.format(_bundle_hash, name)]
    else:
        module.__package__ = sys.modules[qf_parent_name].__package__

    # import hook for modules using __import__ the wrong way
    def _packer_import_hook(name, globals=None, locals=None, fromlist=(), level=0):
        return _packer_import(
            name,
            globals if globals is not None else module.__dict__,
            locals if locals is not None else module.__dict__,
            fromlist,
            level,
        )

    setattr(module, '__import__', _packer_import_hook)

    # inject code
    exec(virtual_module['code'], module.__dict__)

    # link to parent
    setattr(sys.modules[qf_parent_name], local_name, module)


def _try_get_module_all_list(name):
    qf_name = '{}.{}'.format(__name__, name) if name else __name__
    module = sys.modules.get(qf_name, None)
    if module:
        all_list = getattr(module, '__all__', None)
        if all_list:
            return all_list
    return []


_orig_import = builtins.__import__


def _packer_import(name, globals=None, locals=None, fromlist=(), level=0):

    globals_or_empty = globals if globals else {}

    # determine load path
    if level > 0:
        load_path = globals_or_empty.get(
            '__package__',
            globals_or_empty['__name__'],
        ).split('.')
        if level > 1:
            load_path = load_path[:-(level - 1)]
    else:
        load_path = []
    load_path += name.split('.') if name else []

    # handle hoisted requests with rebased path
    if '.'.join(load_path) == __name__ or '.'.join(load_path).startswith(
            __name__ + '.'):
        load_path = load_path[len(__name__.split('.')):]

    # skip load requests not originating from the bundle
    elif globals_or_empty.get('__packer_bundle_hash__', None) != _bundle_hash:
        load_path = None

    # try to load and return module if load path is given
    if load_path is not None:

        # load modules along the path
        for depth in range(len(load_path)):
            _try_load_module(
                '.'.join(load_path[0:depth + 1]),
                load_path[depth],
                '.'.join(load_path[0:depth]) if depth > 0 else None,
                True,
            )

        # load modules referenced by the from list
        if fromlist:
            for from_item in fromlist:
                if from_item == '*':
                    all_list = _try_get_module_all_list(
                        '.'.join(load_path) if load_path else None,
                    )
                    for all_item in all_list:   
                        _try_load_module(
                            '.'.join(load_path + [all_item]),
                            all_item,
                            '.'.join(load_path) if load_path else None,
                            False,
                        )
                _try_load_module(
                    '.'.join(load_path + [from_item]),
                    from_item,
                    '.'.join(load_path) if load_path else None,
                    False,
                )

        # try to return the requested module
        if load_path:
            if not fromlist:
                return_name = '{}.{}'.format(__name__, load_path[0])
            else:
                return_name = '{}.{}'.format(__name__, '.'.join(load_path))

            if return_name in sys.modules:
                return sys.modules[return_name]

    # delegate import to original routine
    return _orig_import(name, globals, locals, fromlist, level)


builtins.__import__ = _packer_import


if sys.version_info >= (3, 0):

    # If we import this library in Python 2.x, the library can no longer be
    # imported by other modules. Weird behaviour, we would like to avoid.
    # So keep this import here!
    import importlib

    class _PackerLoader(importlib.abc.Loader):

        def __init__(self, code):
            self.code = code

        def create_module(self, spec):
            return None

        def exec_module(self, module):
            exec(self.code, module.__dict__)

    class _PackerMetaFinder(importlib.abc.MetaPathFinder):

        def find_spec(self, fullname, path, target=None):

            # construct load path
            load_path = fullname.split('.')

            # handle hoisted requests with rebased path
            if '.'.join(load_path).startswith(__name__ + '.'):
                load_path = load_path[len(__name__.split('.')):]

            # skip load requests not originating from the bundle
            elif not path or not path[0].startswith(
                    '{}/'.format(_bundle_hash)):
                return None

            # load module
            virtual_name = '.'.join(load_path)
            virtual_module = _virtual_modules.get(virtual_name, None)
            if not virtual_module:
                return None

            # create spec
            return importlib.util.spec_from_loader(
                virtual_name,
                loader=_PackerLoader(virtual_module['code']),
                is_package=True if virtual_module['is_package'] else None,
            )

    sys.meta_path.insert(0, _PackerMetaFinder())
